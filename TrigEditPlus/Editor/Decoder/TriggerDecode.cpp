/*
 * Copyright (c) 2014 trgk(phu54321@naver.com)
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include "../TriggerEditor.h"
#include "../TriggerEncDec.h"
#include "../StringUtils/StringCast.h"

DWORD crc32(const void *buf2, size_t len);
void LuaAutoRequireLibs(lua_State* L);

// Decode part

int lPanic(lua_State* L)
{
	MessageBox(NULL, lua_tostring(L, -1), "Error", MB_OK);
	abort();
}

std::string TriggerEditor::DecodeTriggers(CChunkData* Triggers) const {
	// Initialize hooks
	lua_State* L = luaL_newstate();
	lua_atpanic(L, lPanic);
	LuaAutoRequireLibs(L);

	lua_getglobal(L, "SortHooks");
	lua_pcall(L, 0, 0, 0);

	// Some notice
	StringBuffer decode_out;
	decode_out << "-- This text is generated by TrigEditPlus\r\n\r\n";

	std::vector<TrigBufferEntry> tbev;

	// Decode triggers
	std::vector<Trig> trigv;
	{
		size_t trign = Triggers->ChunkSize / 2400;
		Trig* trigdata = (Trig*)Triggers->ChunkData;
		for(size_t i = 0 ; i < trign ; i++) {
			TrigBufferEntry tbe;
			tbe.trigData = *trigdata;
			tbe.callerLine = decode_out.GetCurrentLine();
			tbev.push_back(tbe);

			DecodeTrigger(L, decode_out, *trigdata++);

			decode_out << "\r\n";
		}
	}

	lua_close(L);

	// TODO : current code is VERY VERY DIRTY. Clean everythin!!!!!!!!
	const_cast<TriggerEditor*>(this)->UpdateTriggerList(tbev);

	std::string ret = decode_out.str();
	decode_out.clear();
	return ret;
}


void TriggerEditor::DecodeTrigger(lua_State* L, StringBuffer& buf, const Trig& content) const {
	size_t i;
	char trigCRC32[9];
	sprintf(trigCRC32, "%08X", crc32(&content, 2400));

	int totstrn = StringTable_GetTotalStringNum(_editordata->EngineData->MapStrings);

	// If trigger isn't executed by any of the players, then special-decode that trigger.
	for(i = 0 ; i < 27 ; i++) {
		if(content.effplayer[i]) break;
	}
	if(i == 27) {
		// Ignore that trigger.
		return;
	}



	// 1. Write trigger header
	
	// print comment & header of trigger
	bool comment_singleline = false;
	for(i = 0 ; i < 64 ; i++) {
		if(content.act[i].acttype == 0) { // no comment
			buf << "Trigger { -- No comment (" << trigCRC32 << ")\r\n";
			break;
		}

		else if(content.act[i].acttype == COMMENT) {
			int strid = content.act[i].strid;
			if(strid < 0 || strid > totstrn) break;
			const char* rawcomment0 = StringTable_GetString(_editordata->EngineData->MapStrings, strid);
			if(rawcomment0 == NULL) break;
			if(strchr(rawcomment0, '\n') == NULL) comment_singleline = true;
			else comment_singleline = false;

			// Decode string to lua comments
			std::string rawcomment = rawcomment0;

			char *comment = (char*)alloca(rawcomment.size() * 5 + 4);
			strcpy(comment, "-- ");
			char *p = comment + 3;

			for(char ch : rawcomment) {
				/**/ if(ch == '\t') *p++ = '\t';
				else if(ch == '\r');
				else if(ch == '\n') {
					*p++ = '\r';
					*p++ = '\n';
					*p++ = '-';
					*p++ = '-';
					*p++ = ' ';
				}

				else if(1 <= ch && ch <= 31) continue;
				else *p++ = ch;
			}

			*p = '\0';
			
			if(comment_singleline) {
				buf << "Trigger { " << comment << "\r\n";
			}
			else {
				buf << comment << "\n\nTrigger {\r\n";
			}
			break;
		}
	}
	if(i == 64) buf << "Trigger { -- No comment (" << trigCRC32 << ")\r\n"; // no comment, 64 actions all used.


	// 2. Write player fields
	buf << "\tplayers = {";

	bool firstplayer = true;
	for(int i = 0 ; i < 27 ; i++) {
		if(content.effplayer[i]) {
			if(!firstplayer) buf << ", ";
			else firstplayer = false;
			buf << DecodePlayer(i);
		}
	}
	buf << "},\n";

	// 2. Write conditions.
	if(content.cond[0].condtype != 0) { // There is at least one condition.
		buf << "\tconditions = {\r\n";

		for(i = 0 ; i < 16 ; i++) {
			if(content.cond[i].condtype == 0) break;
			DecodeCondition(L, buf, content.cond[i]);
		}

		buf << "\t},\r\n";
	}


	// 3. Write actions.
	if(content.act[0].acttype != 0) { // There is at least one action.
		buf << "\tactions = {\r\n";

		for(i = 0 ; i < 64 ; i++) {
			if(content.act[i].acttype == 0) break;
			DecodeAction(L, buf, content.act[i]);
		}
		
		buf << "\t},\r\n";
	}

	// 4. Print auxilarry informations
	std::vector<const char*> auxinfo;
	if(content.flag & 1) auxinfo.push_back("actexec");
	if(content.flag & 4) auxinfo.push_back("preserved");
	if(content.flag & 8) auxinfo.push_back("disabled");

	if(!auxinfo.empty()) {
		buf << "\tflag = {" << auxinfo[0];
		for(i = 1 ; i < auxinfo.size() ; i++) {
			buf << ", " << auxinfo[i];
		}
		buf << "},\r\n";
	}

	// 5. Print starting condition
	if(content.current_action != 0) {
		buf << "\tstarting_action = " << content.current_action << ",\r\n";
	}

	buf << "}\r\n";
}